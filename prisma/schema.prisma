// schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Usuario {
  id                  Int           @id @default(autoincrement())
  clerkId             String?       @unique  // ID del usuario en Clerk
  nombre              String
  apellido            String
  rut                 String        @unique
  correo              String        @unique
  password            String?
  fecha_de_nacimiento DateTime?
  rol                 String?       // 'comprador', 'vendedor', 'administrador'
  
  // Campos de Mercado Pago
  mp_account_id       String?       // ID de cuenta de Mercado Pago
  mp_access_token     String?       // Token de acceso de Mercado Pago
  mp_refresh_token    String?       // Token de actualización de Mercado Pago
  mp_token_expires    DateTime?     // Fecha de expiración del token
  mp_connected        Boolean       @default(false) // Indica si la cuenta está conectada a MP
  
  metodo_pago        String?       // ID del método de pago en la pasarela de pagos
  cuenta_vendedor    String?       // ID de cuenta de vendedor en Stripe, Mercado Pago, etc.
  creado_en          DateTime      @default(now())
  verificado         Boolean       @default(false)
  foto_perfil        String?       // URL de la foto de perfil del usuario
  
  // Relaciones
  ticketsVendidos    Ticket[]      @relation("Vendedor")
  compras            Compra[]      @relation("Comprador")
  valoraciones       Valoracion[]  @relation("VendedorValoracion")
  disputas           Disputa[]     @relation("CompradorDisputa")
  notificaciones     Notificacion[]
  Valoracion         Valoracion[]
}

model TipoEntrada {
  id          Int       @id @default(autoincrement())
  nombre      String    // 'VIP', 'Palco', 'General', etc.
  descripcion String?
  precio_base Decimal   // Precio base sugerido para este tipo de entrada
  evento_id   Int
  evento      Evento    @relation(fields: [evento_id], references: [id])
  tickets     Ticket[]  // Relación con los tickets
}


model Evento {
  id                Int       @id @default(autoincrement())
  nombre            String
  ubicacion         String
  fecha_evento      DateTime
  url_foto          String
  descripcion       String?
  creado_en         DateTime  @default(now())
  categoria         String
  tickets           Ticket[]
  tipos_entrada     TipoEntrada[]
}

model Ticket {
  id                Int       @id @default(autoincrement())
  evento_id         Int
  vendedor_id       Int
  tipo_entrada_id   Int  
  precio            Decimal
  estado            String    // 'disponible', 'vendido', 'cancelado'
  archivo_url       String?
  fecha_creacion    DateTime  @default(now())
  fecha_vencimiento DateTime
  tipo_entrada      TipoEntrada @relation(fields: [tipo_entrada_id], references: [id]) // Nueva relación
  evento            Evento     @relation(fields: [evento_id], references: [id])
  vendedor          Usuario    @relation("Vendedor", fields: [vendedor_id], references: [id])
  compras           Compra[]
  disputas          Disputa[]  @relation("TicketDisputa") // Campo de relación agregado
}

model Compra {
  id                     Int       @id @default(autoincrement())
  ticket_id              Int
  comprador_id           Int
  precio_total           Decimal
  fecha_compra           DateTime  @default(now())
  
  // Campos específicos de Mercado Pago
  mp_payment_id          String?   // ID del pago en Mercado Pago
  mp_payment_status      String?   // Estado del pago en Mercado Pago
  mp_merchant_order_id   String?   // ID de la orden en Mercado Pago
  mp_preference_id       String?   // ID de la preferencia de pago
  mp_external_reference  String?   // Referencia externa del pago
  
  estado                 String    // 'pending', 'approved', 'rejected', 'cancelled'
  fondos_liberados       Boolean   @default(false)
  fecha_fondos_liberados DateTime?
  confirmacion           Boolean   @default(false)
  
  // Relaciones
  ticket                 Ticket    @relation(fields: [ticket_id], references: [id])
  comprador              Usuario   @relation("Comprador", fields: [comprador_id], references: [id])
  disputas               Disputa[]
  paymentPreference      PaymentPreference[]
}

model Disputa {
  id              Int       @id @default(autoincrement())
  compra_id       Int
  comprador_id    Int
  ticket_id       Int
  descripcion     String?
  estado          String    // 'abierta', 'resuelta'
  fecha_creacion  DateTime  @default(now())
  
  // Relaciones
  compra          Compra    @relation(fields: [compra_id], references: [id])
  comprador       Usuario   @relation("CompradorDisputa", fields: [comprador_id], references: [id])
  ticket          Ticket    @relation("TicketDisputa", fields: [ticket_id], references: [id])
}
model Valoracion {
  id              Int       @id @default(autoincrement())
  vendedor_id     Int
  comprador_id    Int
  puntuacion      Int       // Puntuación del 1 al 5
  comentario      String?
  fecha_creacion  DateTime  @default(now())
  
  // Relaciones
  vendedor        Usuario   @relation("VendedorValoracion", fields: [vendedor_id], references: [id])
  comprador       Usuario   @relation(fields: [comprador_id], references: [id])
}
// Nuevo modelo para manejar webhooks de Mercado Pago
model MercadoPagoWebhook {
  id            Int       @id @default(autoincrement())
  type          String    // Tipo de notificación
  data          Json      // Datos del webhook
  processed     Boolean   @default(false)
  created_at    DateTime  @default(now())
  processed_at  DateTime?
}

model PaymentPreference {
  id                Int      @id @default(autoincrement())
  mp_preference_id  String   @unique
  compra_id         Int
  status            String   // 'pending', 'approved', 'rejected'
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt
  
  // Relaciones
  compra            Compra   @relation(fields: [compra_id], references: [id])
}

model Notificacion {
  id                Int       @id @default(autoincrement())
  usuario_id       Int
  mensaje          String
  leido            Boolean    @default(false) // Indica si la notificación ha sido leída
  fecha_creacion    DateTime  @default(now())
  usuario          Usuario    @relation(fields: [usuario_id], references: [id])
}